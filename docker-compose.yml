
services:
    # upgrade with https://hub.docker.com/r/tianon/postgres-upgrade/tags 
    db:
        image: docker.io/library/postgres:14 #define the image to get
        restart: always
        volumes:
            - pgvolume14:/var/lib/postgresql/data
            - ./postgres/docker-entrypoint-initdb.d:/docker-entrypoint-initdb.d
        env_file: env
        networks:
            - cc


    redis:
        restart: always
        image: docker.io/library/redis:latest
        expose:
            - "6379"
        networks:
            - cc


    celery:
        restart: always
        # Docker hack to wait until Postgres is up, then run stuff.
        command: /usr/local/bin/celery -A cc.celery worker
        build: ./iypt-cc/
        volumes:
            - webmedia:/data/glue-media
            #- /var/run/docker.sock:/var/run/docker.sock
            - ./tex_share:/data/tex_share
        depends_on:
            - db
            - web
        env_file: env
        environment:
            IN_DOCKER: 1
        networks:
            - cc

    web:
        restart: always

        # Docker hack to wait until Postgres is up, then run stuff.
        command: /bin/sh -c "while ! nc -w 1 -z db 5432; do sleep 0.1; done; /usr/bin/python3 manage.py migrate; /usr/bin/python3 manage.py collectstatic --noinput; /usr/local/bin/gunicorn cc.wsgi:application -w 21 --timeout 120 -b :8000"
        build: ./iypt-cc/
        volumes:
            - webstatic:/data/django/static
            - webmedia:/data/glue-media
            - ./backup:/data/dbbackup
        depends_on:
            - db
        env_file: env
        environment:
            IN_DOCKER: 1
        networks:
            - cc

    socket:
        restart: always

        # Docker hack to wait until Postgres is up, then run stuff.
        command: /bin/sh -c "while ! nc -w 1 -z db 5432; do sleep 0.1; done; /usr/local/bin/daphne -b 0.0.0.0 -p 8000 --proxy-headers --access-log - cc.asgi:application"
        build: ./iypt-cc/
        depends_on:
            - db
            - redis
        env_file: env
        environment:
            IN_DOCKER: 1
        networks:
            - cc

    nginx-django:
        restart: always
        image: nginx
        #volumes:
        #    - ./maintenance:/data/maintenance
        ports:
            - "8000:80"
        volumes:
            - "./nginx.d:/etc/nginx/conf.d"
            - webstatic:/data/django/static
            - webmedia:/data/glue-media
        depends_on:
            - web
        labels:
            - "traefik.enable=true"
            - "traefik.http.routers.cc.rule=Host(`cc.your-domain.tld`)"
            - "traefik.http.routers.cc.service=cc"
            - "traefik.http.services.cc.loadbalancer.server.port=80"
            - "traefik.http.routers.cc.entryPoints=websecure"
            - "traefik.http.routers.cc.tls=true"
            - "traefik.http.routers.cc.tls.certresolver=le"
        networks:
           cc:

    xelatex:
        build: ./xelatex/
        command: sleep 1000d

volumes:
    pgvolume14:  #declare a volume named pgvolume
    web:
    webmedia:
    webstatic:

networks:
  # Internal network for communication with PostgreSQL/MySQL
  cc:
